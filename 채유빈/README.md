## 번들링이란

### 번들링

- 여러 자바스크립트 파일과 의존성을 하나 또는 여러 개의 최적화된 파일로 **묶는** 과정

<br/>

### 번들링이 필요한 이유

> 개발 단계에서는 모듈 시스템을 통해 코드를 세분화하여 관리한다. 하지만 실제 배포 환경에서는 너무 많은 파일 요청이 성능 저하로 이어질 수 있기 때문에, 이를 해결하기 위해 모듈 번들러가 등장했고, 여러 모듈 파일을 하나로 묶어(번들링) 배포한다.


- **코드 최적화**
    - 불필요한 코드 제거(ex. 트리 쉐이킹), 압축을 통한 성능 향상
    - 파일 크기 감소
- **HTTP 요청 최소화**
    - 여러 파일을 하나로 합쳐 네트워크 요청 수 감소
- **애플리케이션 임의 조작 방지**
    - 번들링된 웹 애플리케이션은 사용자가 임의로 조작할 수 없게 하여 애플리케이션의 무결성과 보안 강화
- **모듈 호환성**
    - 다양한 모듈 시스템(CommonJS, AMD, ESM)을 브라우저에서 작동 가능하게 변환
- **개발 경험 개선**
    - 개발자가 모듈화된 코드를 작성할 수 있게 함


<br/>

### 모듈 시스템

- **CommonJS**
    - Node.js에서 사용하는 `require()`/`module.exports` 기반 모듈 시스템
- **ESM** (ECMAScript Modules): 표준 자바스크립트 모듈 시스템, `import`/`export` 문법 사용
- **AMD** (Asynchronous Module Definition)
    - 비동기 모듈 로딩을 위한 시스템
    - 주로 브라우저 환경에서 사용

>  **모듈 시스템**: 코드를 잘게 나누어 개발 효율성을 높이는 체계  
**번들링**: 이렇게 분리된 모듈 파일들을 실제 서비스에 적합하게 하나로 묶어주는 과정  
→ 모듈 시스템이 코드 구조를 담당하고, 번들러는 이를 실제 운영 환경에 맞게 최적화하는 역할


<br/>

### 번들링 vs 트랜스파일링 vs 트리쉐이킹

- **번들링**: 여러 파일을 하나로 묶는 과정
- **트랜스파일링**: 한 언어의 코드를 다른 언어나 버전으로 변환하는 것 (ex. TS → JS, ES2022 → ES5)
- **트리쉐이킹**: 사용하지 않는 코드를 제거하는 최적화 기법 (번들 크기 감소)


<br/>

## Webpack

### Webpack 이전의 번들링

- 초기: 수동으로 스크립트 파일을 병합
- Grunt/Gulp: 태스크 러너를 활용한 파일 연결
- Browserify: Node.js 스타일 모듈을 브라우저에서 사용할 수 있게 한 초기 번들러

<br/>

### Webpack의 등장

- 2012년 출시, 모듈 번들러의 주류로 자리잡음
- 자바스크립트 뿐만 아니라, CSS, 이미지 등 모든 리소스를 모듈로 처리
- 로더와 플러그인을 통한 확장성
- 코드 스플리팅, HMR(Hot Module Replacement) 등 개발 경험 향상 기능 제공

<br/>

### Webpack 설정의 핵심 요소

- **Entry**: 모듈 의존성 그래프의 시작점
    
    ```jsx
    // webpack.config.js
    
    // Single Page Application(SPA)
    module.exports = {
      entry: './src/index.js'
    }
    
    // Multi Page Application (MPA)
    module.exports = {
      entry: {
        login: './src/LoginView.js',
        main: './src/MainView.js'
      }
    }
    ```
    
- **Output**: 번들된 파일의 저장 위치 및 이름
    
    ```jsx
    // webpack.config.js
    var path = require('path');
    
    module.exports = {
      output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, './dist')
      }
    }
    
    /* Node.js API가 하는 역할은 아래 코드와 동일하다. */
    output: './dist/bundle.js'
    ```
    
- **Loader**: 자바스크립트가 아닌 파일을 모듈로 변환 (ex. css-loader, babel-loader)
    
    ```jsx
    // test 정규식으로 대상 파일 필터링
    module: {
      rules: [
        { test: /\.css$/, use: ['style-loader', 'css-loader'] }, 
        { test: /\.ts$/, use: 'ts-loader' }
      ]
    }
    ```
    
- **Plugin**: 번들 최적화, HMR, 환경 변수 주입 등 추가 기능 제공
    
    ```jsx
    // webpack.config.js
    var webpack = require('webpack');
    var HtmlWebpackPlugin = require('html-webpack-plugin');
    
    module.exports = {
      plugins: [
        new HtmlWebpackPlugin(),
        new webpack.ProgressPlugin()
      ]
    }
    ```
    
<br/>

### Webpack의 의존성 관리

- **의존성 그래프** (Dependency Graph)
    - 엔트리 포인트부터 시작해 모든 모듈의 의존 관계를 그래프 구조로 분석 (정적 분석)
- **모듈 해석 규칙** (Resolution Rules)
    - 3가지 경로 유형별 처리 방식
        
        
        | 경로 유형 | 해석 방법 | 예시 |
        | --- | --- | --- |
        | 절대 경로 | 바로 사용 | `import '/src/app.js'` |
        | 상대 경로 | 현재 파일 위치 기준 계산 | `import ‘../components/Button’` |
        | 모듈 경로 | `node_modules` 탐색 | `import ‘react’` |
    - 주요 설정 옵션
        
        ```jsx
        // webpack.config.js
        resolve: {
          modules: ['node_modules'], // 모듈 검색 디렉토리
          extensions: ['.js', '.jsx'], // 확장자 생략 허용
          alias: {
            '@components': path.resolve(__dirname, 'src/components/') // 별칭 설정
          }
        }
        ```
        
- 실제 해석 프로세스 예시
    1. `import Button from '@components/Button'` 발생
    2. `alias` 설정에 따라 `@components` → `src/components/` 변환
    3. `src/components/Button.jsx` 파일 탐색
    4. 확장자 생략 시 `resolve.extensions` 설정 순서대로 검색
    5. `package.json`의 `module` 필드 확인 후 진입점 결정

<br/>

### Webpack의 번들 워크플로우

1. **Entry 분석**: Entry에서 의존성 추적 시작  
2. **Loader 처리**: CSS/이미지 등 리소스 변환  
3. **Plugin 적용**: 번들 최적화 및 추가 기능 연동  
4. **의존성 해석**: 모듈 경로 매핑 및 그래프 구축   
5. **코드 분할**: 사용 패턴에 따른 청크 생성   
6. **출력 생성**: 결과물 저장 폴더에 최종 번들 파일 작성  

<br/>

### Webpack의 최적화 전략

- **트리 쉐이킹** (Tree Shaking)
    - 빌드 시 사용하지 않는 코드 제거
    - ES Module(import/export)의 정적 구조 분석
    - `sideEffects` 플래그를 통해 CSS 등의 리소스 보존 설정
        
        ```json
        // package.json
        {
          "sideEffects": ["*.css", "*.scss"]  // CSS 파일은 제거되지 않음 
        }
        ```
        
- **코드 스플리팅** (Code Splitting)
    - 청크를 논리적 단위로 분할
        
        
        | 접근 방식 | 설명 | 예시 코드 |
        | --- | --- | --- |
        | 엔트리 포인트 분할 | 수동으로 엔트리 지정 | `entry: { app: './app.js', admin: './admin.js' }`  |
        | 중복 방지 | 몇 가지 옵션을 사용해 청크 간에 모듈 공유 | `optimization: { splitChunks: { chunks: 'all' } }` |
        | 동적 임포트 | **`import()`** 구문 사용 | `import(/* webpackChunkName: "lodash" */ 'lodash')`  |
- **레이지 로딩** (Lazy Loading)
    - 실제 필요 시점에 청크 로드

<br/>

### Webpack의 개발 서버와 HMR

- **Webpack Dev Server**
    - 핵심 기능
        - **실시간 리로드**: 코드 변경 시 자동으로 브라우저 새로고침 (live-reload)
        - **메모리 내 번들링**: 파일 시스템 대신 메모리에 번들 저장 (빠른 빌드)
        - **프록시 설정**: API 요청을 다른 서버로 전달 (CORS 문제 해결)
- **HMR** (Hot Module Replacement)
    - 작동 원리
        1. **변경 감지**: 파일 수정 시 웹팩이 모듈 변경 사항 감지
        2. **업데이트 전송**: 웹소켓을 통해 브라우저에 변경 사항 알림
        3. **모듈 교체**: 새 모듈 코드로 실시간 교체 (전체 페이지 리로드 X)
    - 장점
        - **상태 보존:** 폼 입력값, 스크롤 위치 등 유지
        - **빠른 피드백**: 평균 2초 내 변경사항 반영
        - **에러 표시**: 실패 시 정확한 위치의 에러 메시지 출력
- 통합 워크플로우
    1. 개발자 코드 수정 → 저장
    2. 웹팩 Dev Server 변경 감지
    3. HMR 엔진이 변경된 모듈 식별
    4. 새 모듈 코드를 런타임에 주입
    5. 브라우저 UI 부분 업데이트 (전체 리로드 X)

<br/>

### Module Federation

- Webpack 5에서 도입된 기능으로, 여러 개의 독립적으로 빌드되고 배포된 애플리케이션(또는 모듈)을 **런타임에** 하나의 앱처럼 통합해서 사용할 수 있게 해주는 기술
- 마이크로 프론트엔드 (Micro Frontend) 아키텍처에 적합
    - 대규모 프로젝트에서 각 도메인(ex. 쇼핑, 결제, 마이페이지)을 별도 앱으로 개발한 뒤, 런타임에 하나로 합쳐 시스템의 확장성과 유지보수성 향상
- 기존의 정적 번들링과의 차이점
    - 정적 번들링
        - 전통적인 웹팩 번들링 방식에서는 여러 애플리케이션이나 모듈을 하나의 번들 파일로 **빌드 타임에** 미리 합침
        - 이 경우, 어떤 모듈이 변경되면 전체 번들을 다시 빌드하고 배포해야 하며, 앱 간의 독립적인 배포가 어려움
    - Module Federation의 동적 번들링
        - 각 애플리케이션이 독립적으로 빌드, 배포된 뒤, **브라우저 런타임에서 서로의 모듈을 동적으로 로드하여 통합**
        - 즉, 앱 실행 시점에 외부(remote) 모듈을 HTTP로 받아와서 조립하고, 필요할 때만 해당 모듈을 불러옴

<br/>

## 최신 번들러

- **Vite**: 개발 시 ESM을 활용한 빠른 개발 서버, 프로덕션 빌드는 Rollup 사용
- **Rollup**: ES 모듈에 초점, 라이브러리 번들링에 최적화
- **esbuild**: Go로 작성되어 매우 빠른 속도를 자랑
- **Parcel**: 제로 설정으로 사용 가능한 번들러, 쉬운 사용성

<br/>

### 주요 번들러 비교 분석

| 번들러 | 강점 | 약점 | 주요 사용 사례 | 실제 사용 사례 |
| --- | --- | --- | --- | --- |
| Webpack | 풍부한 생태계와 안정성, 다양한 플러그인 | 느린 시작 시간과 복잡한 설정 | 대규모 SPA, 기업용 애플리케이션 | Facebook, Airbnb, Twitter |
| Vite | 빠른 개발 서버, 간단한 설정 | 프로덕션 단계에서 Rollup 의존 | 모던 프레임워크 기반 개발(Vue, React) | 최신 Vue/React 프로젝트 |
| Rollup | 효율적인 트리쉐이킹, 작은 번들 사이즈 | 개발 서버 기능 부족 | 라이브러리, npm 패키지 | React, Vue, Angular |
| esbuild | 매우 빠른 속도 | 플러그인 생태계 부족 | 빌드 시간이 중요한 대규모 프로젝트 | Netlify, Deno, Vercel |

<br/>

## Vite

### Vite의 탄생 배경

- 기존 번들러의 한계
    - Webpack 등 전통적은 번들러는 개발 서버를 시작할 때 전체 프로젝트를 한 번에 번들링, 따라서 프로젝트가 커질수록 서버 시작(Cold Start)과 코드 변경 시의 반영(Hot Reload)이 점점 느려짐
- ES Modules(ESM)의 등장
    - 브라우저가 네이티브로 ES 모듈을 지원하게 되면서, 더 이상 모든 코드를 한 번에 번들링하지 않아도 되는 환경이 갖춰짐
        
    > ES 모듈을 브라우저가 네이티브로 지원하기 전에는, **모듈화된 자바스크립트 코드를 브라우저에서 직접 실행할 수 없었기 때문에(**여러 개의 자바스크립트 파일 간의 의존성을 이해하거나, import/export 구문 해석 불가능) 사실상 모든 코드를 한 번에 번들링해야 했음       
- 빠른 개발 피드백의 필요
    - 기존 번들러의 느린 반영 속도는 생산성을 저해하는 주요 원인

<br/>

### Vite의 속도 비결

- **개발 서버에서 번들링 없이 ESM 기반으로 동작**
    - 네이티브 ESM을 활용한 빠른 시작 및 업데이트
    - 개발 중에는 소스 코드를 ES 모듈로 제공하고, 브라우저가 필요한 모듈만 실시간으로 불러옴
    - 전체 번들링이 필요없어 서버 시작과 변경 반영이 매우 빠름
- **esbuild 활용한 사전 번들링**
    - 의존성(라이브러리) 코드는 Go 언어로 작성된 esbuild를 사용해 미리 번들링 (10~100배 빠른 속도 실현)
- **프로덕션 빌드는 Rollup 기반**
    - 실제 배포 시에는 Rollup을 사용해 최적화된 번들 사용
    - Webpack과 유사하지만, 개발 경험은 훨씬 빠름

<br/>

## 모노레포 (Monorepo)

- **여러 개의 프로젝트를 하나의 레포지토리에서 함께 관리**하는 소프트웨어 개발 전략
- 프로젝트별로 각각 저장소를 두는 멀티레포(Multirepo)와 달리, 모든 프로젝트가 하나의 저장소에 공존

<br/>

### 탄생 배경

- 멀티레포 방식에서는 공통 코드의 공유가 어렵고, 여러 프로젝트의 버전, 의존성, 코드 일관성 관리가 복잡해지는 문제가 있었음
- 대규모 조직이나 여러 팀이 협업하는 환경에서 **공통 코드의 재사용**과 **의존성 관리**를 효율적으로 하기 위해 등장

<br/>

### 모노레포의 장점

- **코드 공유와 재사용 용이**
    - 여러 프로젝트가 같은 저장소에 있어 공통 모듈이나 유틸리티를 쉽게 공유 및 재사용 가능
- **일관된 버전 및 의존성 관리**
    - 모든 프로젝트가 동일한 라이브러리 버전을 사용하도록 강제할 수 있음
- **Atomic 변경 및 대규모 리팩토링**
    - 여러 프로젝트에 걸친 변경 사항을 한 번에 적용하고, 하나의 커밋으로 관리 가능
- **효율적인 코드 리뷰 및 CI/CD**
    - 코드 리뷰와 자동화된 테스트/배포 파이프라인을 통합적으로 관리 가능
- **팀 간 협업 용이**
    - 여러 팀이 같은 코드베이스에서 작업하므로 커뮤니케이션이 원활해지고, 코드 품질이 향상됨

<br/>

### 모노레포의 단점

- **저장소 크기 증가**
    - 모든 프로젝트가 한 저장소에 있기 때문에 저장소가 매우 커질 수 있음
- **빌드/테스트 시간 증가**
    - 전체 프로젝트를 빌드하거나 테스트할 때 시간이 오래 걸릴 수 있음
- **의존성 충돌 가능성**
    - 프로젝트마다 요구하는 라이브러리 버전이 다를 경우 충돌이 발생할 수 있음
- **복잡한 저장소 관리**
    - 폴더 구조, 권한 관리, 접근 제어 등이 복잡해질 수 있음

<br/>

### 모노레포 환경에서의 번들링 전략

1. 공유 모듈 처리 방식 비교
    
    
    | 구분 | External 처리 (Module Federation) | Local Build |
    | --- | --- | --- |
    | 방식 | 런타임에 원격 모듈 동적 로드 | 각 패키지에 모듈 포함 빌드 |
    | 장점 | 중복 코드 제거, 독립 배포 가능 | 설정 단순, 네트워크 의존성 없음 |
    | 단점 | 네트워크 지연 가능성, 버전 관리 복잡 | 번들 크기 증가, 업데이트 시 전체 재배포 필요 |
    | 적용 예시 | **`shared: ['react', 'lodash']`**  | **`npm install ../shared-lib`** |
    | 사용 사례 | 마이크로 프론트엔드 아키텍처 | 소규모 모노레포 |
2. Micro Frontend/Module Federation 도입 시 고려사항
    - 버전 관리
    - 네트워크 최적화
    - 트리 쉐이킹
3. Multi Package 환경 번들 크기 제어법
    - 빌드 도구 활용
        - Nx/Turborepo: 변경된 패키지만 증분 빌드
        - Webpack Module Federation: 공통 의존성 싱글톤화
    - 코드 분할 전략
        - Route-based 코드 스플리팅
        - 동적 임포트(`import()`) 활용
    - 모던 번들러 도입
    - 모니터링 시스템
        - Webpack Bundle Analyzer
        - Lighthouse 성능 리포트 자동화
        - CI/CD 파이프라인에 번들 크기 제한 설정

<br/>

## **번들링 대체 전략과 현대 웹의 흐름**

### 번들리스(Bundless) 접근

- Import Maps
    - 브라우저가 자바스크립트 모듈을 로드할 때, 모듈 이름을 실제 URL(ex. CDN 경로)로 매핑해주는 방식
    - 이를 통해 빌드나 번들 없이도, 브라우저가 직접 외부 라이브러리를 ESM 형태로 로드할 수 있음
- Native ESM
    - `<script type="module">`로 시작하는 스크립트는 브라우저가 직접 외부 모듈 의존성을 파악해 필요한 파일만 로드
    - 별도의 번들 없이도 모듈러 개발이 가능해졌으며, 번들러의 필요성이 줄어들고 있음

<br/>

### Edge 컴퓨팅, Server Components와 번들의 역할 변화

- **Edge 컴퓨팅**
    - 데이터와 연산을 클라우드가 아닌 사용자와 가까운 엣지(Edge) 서버에서 처리하는 방식이 확산
    - 엣지에서 필요한 코드만 빠르게 배포하거나, 사용자 위치에 따라 맞춤형 번들 혹은 모듈만 전송하는 전략이 중요해짐
    - 번들 크기 최소화, 네트워크 지연 감소, 실시간성 확보가 핵심이 되며, 중앙 집중식 대용량 번들보다는 분산·동적 로딩이 부각됨
- **Server Components (React 등)**
    - 클라이언트로 보내는 번들에는 서버에서만 필요한 코드(예: DB 접근, 비싼 연산 등)가 포함되지 않으므로, 번들 크기를 크게 줄일 수 있음
    - SSR(서버 사이드 렌더링)과 결합해, 클라이언트에는 최소한의 JS만 전송하고, 나머지는 서버에서 처리
    - 번들의 역할이 “모든 UI/로직을 클라이언트에 실어 나르는 것”에서 “클라이언트에 꼭 필요한 코드만 보내는 것”으로 변화함

<br/>

### SSR/SSG 환경에서의 번들 구성

- **SSR (Server-Side Rendering)**
    - 서버가 HTML을 미리 렌더링해 보내고, 클라이언트는 번들된 JS를 받아 상호작용을 담당
    - SSR 환경에서는 페이지별, 라우트별로 번들 크기를 조절하거나, 필요에 따라 동적 로딩 적용
    - 서버 컴포넌트, 코드 스플리팅, 레이지 로딩 등과 결합해 번들 크기와 초기 로딩 시간 최소화
- **SSG (Static Site Generation)**
    - 빌드 시점에 HTML을 미리 생성해두고, 클라이언트에는 필요한 JS 번들만 제공
    - 페이지별로 필요한 코드만 분리해 번들링하며, 불필요한 코드가 클라이언트에 전달되지 않도록 최적화

<br/>

> 전체적으로, `모든 코드를 한 번에 번들링`하는 시대에서 `필요한 코드만, 필요한 시점에, 최적의 위치에서 제공`하는 아키텍처로 진화하고 있음
